<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Defend Thy Castle</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&display=swap" rel="stylesheet">
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <style>
        body {
            font-family: 'MedievalSharp', serif;
            background-color: #f0f4f8;
            color: #2c2c2c;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        #game-container {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #ffffff;
            border-radius: 0;
            box-shadow: none;
            padding: 0;
            /* Set container to fill viewport height and maintain aspect ratio */
            height: 100vh;
            width: calc(100vh * (1080 / 2424)); /* Default aspect ratio, will be adjusted by JS */
            max-width: 100vw;
            max-height: 100vh;
            margin: auto; /* Center the container if the window is wider than the game aspect ratio */
        }

        canvas {
            border: none;
            background-color: #a3b18a;
            border-radius: 0;
            width: 100%; /* Canvas takes full width of its container */
            height: 100%; /* Canvas takes full height of its container */
            /* The internal resolution will be set in JS, and CSS handles scaling */
            box-shadow: none;
        }
        
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; /* Allow clicks to pass through to canvas by default */
        }

        .stats-overlay {
            display: flex;
            gap: 10px;
            padding: 10px;
            pointer-events: auto; /* Re-enable pointer events for stats */
            position: absolute;
            top: 20px; /* Increased spacing from top */
            left: 20px; /* Increased spacing from left */
        }

        .stats-overlay div {
            background-color: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(5px);
            padding: 8px 12px;
            border-radius: 8px;
            font-weight: bold;
            color: #2c2c2c;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
        }
        .stats-overlay div span {
            padding-left: 8px;
        }

        #tower-buttons {
            pointer-events: auto; /* Re-enable pointer events for buttons */
            position: absolute;
            bottom: 170px; /* Moved down by 50px (from 120px) */
            left: 20px; /* Moved to left side */
            display: flex;
            flex-direction: column-reverse; /* Stack buttons vertically, bomb on top */
            gap: 8px; /* Space between buttons */
        }
        
        /* Removed #start-wave-container as it's no longer needed */

        #pause-button-container {
            pointer-events: auto; /* Re-enable pointer events for button */
            position: absolute;
            top: 20px; /* Increased spacing from top */
            right: 20px; /* Increased spacing from right */
            display: none; /* Hidden by default */
        }
        
        button {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            background: rgba(255, 255, 255, 0.8);
            color: #2c2c2c;
            font-family: 'MedievalSharp', serif;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.15);
        }

        button:active {
            transform: translateY(0);
            box-shadow: 0 4-5px 6px rgba(0, 0, 0, 0.1);
        }
        
        /* New button styles for tower purchase buttons */
        #buy-basic-tower, #buy-knight, #buy-cannon-tower, #buy-bomb {
            border-radius: 8px;
            padding: 6px 10px; /* Smaller padding */
            width: auto;
            height: auto;
            display: flex;
            flex-direction: row; /* Align icon and price horizontally */
            align-items: center;
            line-height: 1;
            gap: 6px; /* Reduced space between icon and price */
            font-size: 0.8em; /* Smaller text */
        }
        
        #buy-basic-tower img, #buy-knight img, #buy-cannon-tower img, #buy-bomb img {
            width: 36px; /* Smaller images */
            height: 36px;
        }

        /* Circular pause button */
        #pause-button {
            border-radius: 50%;
            width: 50px; /* Make it a square for a perfect circle */
            height: 50px;
            padding: 0; /* Remove padding to center icon */
            display: flex; /* Use flex to center icon */
            justify-content: center;
            align-items: center;
        }

        #message-box {
            position: absolute;
            background-color: rgba(0, 0, 0, 0.5); /* Subtle background for readability */
            border-radius: 8px;
            padding: 10px 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            color: white; /* White text */
            text-align: center;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none; /* Crucial: allows clicks to pass through */
            width: 80%; /* Adjust width to content */
            max-width: 300px; /* Limit max width */
            white-space: normal; /* Allow text to wrap */
            font-size: 1.2em; /* Make it more prominent */
            z-index: 10;
            font-family: 'MedievalSharp', serif;
        }
        
        #wave-complete-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 10;
            pointer-events: auto;
            font-family: 'MedievalSharp', serif;
            color: #2c2c2c;
        }
        
        #wave-complete-modal h2 {
            color: #2c2c2c;
            margin-top: 0;
            font-family: 'MedievalSharp', serif;
        }

        #game-over-modal {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(5px);
            padding: 30px;
            border-radius: 15px;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
            text-align: center;
            z-index: 10;
            pointer-events: auto;
            font-family: 'MedievalSharp', serif;
            color: #2c2c2c;
            display: none;
        }

        #loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 2rem;
            border-radius: 15px;
            z-index: 100;
            font-family: 'MedievalSharp', serif;
        }

        /* Hide the image elements used for drawing on canvas */
        .hidden-asset {
            display: none;
        }

        #how-to-play-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.85);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            color: white;
            font-family: 'MedievalSharp', serif;
            z-index: 200; /* Above everything else */
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #how-to-play-screen h1 {
            font-size: 2.5em;
            margin-bottom: 20px;
        }

        #how-to-play-screen p {
            font-size: 1.1em;
            margin-bottom: 15px;
            max-width: 80%;
            line-height: 1.5;
        }

        #how-to-play-screen button {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 1.2em;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: background-color 0.3s ease;
        }

        #how-to-play-screen button:hover {
            background-color: #45a049;
        }
    </style>
</head>
<body>

<div id="game-container">
    <div id="loading-overlay">Loading...</div>
    <canvas id="gameCanvas"></canvas>
    <div id="ui-container">
        <div class="stats-overlay">
            <div id="money-stat">üí∞<span>100</span></div>
            <div id="lives-stat">‚ù§Ô∏è<span>20</span></div>
            <div id="wave-stat">üè∞<span>0</span></div>
        </div>
        <div id="tower-buttons">
            <!-- Buttons ordered by cost (lowest to highest), but displayed column-reverse so lowest is at bottom -->
            <!-- Knight Button (25 Gold) -->
            <button id="buy-knight">
                <img src="https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/2ee45746-ae42-414b-b85f-c8d57f99ecea/knight.png" alt="Recruit Knight" onerror="this.src='https://placehold.co/36x36/CCCCCC/000000?text=Error'">
                <span>25 üí∞</span>
            </button>
            <!-- Basic Tower Button (50 Gold) -->
            <button id="buy-basic-tower">
                <img src="https://placehold.co/36x36/6e6e6e/ffffff?text=ARCHER" alt="Buy Basic Tower" onerror="this.src='https://placehold.co/36x36/CCCCCC/000000?text=Error'">
                <span>50 üí∞</span>
            </button>
            <!-- Cannon Tower Button (150 Gold) -->
            <button id="buy-cannon-tower">
                <img src="https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/2751daef-8137-44a9-be9c-6e3a196156e1/tower2.png" alt="Build Cannon Tower" onerror="this.src='https://placehold.co/36x36/CCCCCC/000000?text=Error'">
                <span>150 üí∞</span>
            </button>
            <!-- Bomb Button (175 Gold) -->
            <button id="buy-bomb">
                <img src="https://placehold.co/36x36/000000/FFFFFF?text=üí£" alt="Deploy Bomb" onerror="this.src='https://placehold.co/36x36/CCCCCC/000000?text=Error'">
                <span>175 üí∞</span>
            </button>
        </div>
        <!-- Removed #start-wave-container and #start-wave button -->
        <div id="pause-button-container">
            <button id="pause-button"><i class="fas fa-pause"></i></button>
        </div>
    </div>
    <div id="message-box" style="display: none;"></div>
    <div id="wave-complete-modal" style="display: none;">
        <h2>The onslaught hath been repelled!</h2>
        <p>Prepare for the next wave, brave knight!</p>
        <button id="next-wave-btn">Charge to the Next Wave</button>
    </div>
    <div id="game-over-modal">
        <h2>Hath perished!</h2>
        <p>Thou survived <span id="final-wave"></span> waves.</p>
        <button id="play-again-btn">Play Again</button>
    </div>

    <div id="how-to-play-screen">
        <h1>Defend Thy Castle!</h1>
        <p>Protect your castle (lives) from endless enemy waves.</p>
        <p>
            Tap the buttons in the bottom-left to place units. Place towers on grass for ranged attacks.Deploy on the path for close combat. Tap anywhere to deploy bombs for a powerful explosion.
        </p>
        <p>Defeat enemies to earn gold üí∞ for more units. Clear waves for bonuses. Use the pause button (top right) to take a break.</p>
        <button id="start-game-intro-btn">Start Game</button>
    </div>
</div>

<script>
    window.onload = function() {
        // Get canvas and UI elements
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingOverlay = document.getElementById('loading-overlay');
        const waveCompleteModal = document.getElementById('wave-complete-modal');
        const nextWaveBtn = document.getElementById('next-wave-btn');
        const gameOverModal = document.getElementById('game-over-modal');
        const playAgainBtn = document.getElementById('play-again-btn');
        const pauseButton = document.getElementById('pause-button');
        const pauseButtonContainer = document.getElementById('pause-button-container'); // Get the container

        // How to Play screen elements
        const howToPlayScreen = document.getElementById('how-to-play-screen');
        const startGameIntroBtn = document.getElementById('start-game-intro-btn');

        // Game state variables
        let money = 100;
        let lives = 20;
        let wave = 0;
        let gameActive = false; // Controls if game logic is running (enemies moving, towers firing)
        let gameOver = false;
        let placingTower = false; // Flag for tower placement mode
        let selectedTowerType = null; // Type of tower being placed
        let enemies = [];
        let towers = []; // This array will hold both Archer Towers and Knights
        let projectiles = [];
        let bombs = []; // New array for bombs
        let paused = false; // New state variable for pause
        let waveEndedProcessing = false; // Flag to prevent multiple wave end triggers

        // Rainstorm variables
        let raindrops = [];
        let rainTimer = 0; // Time elapsed since last rainstorm started or ended (in ms)
        let rainActive = false; // Is it currently raining
        const RAIN_INTERVAL_MS = 90 * 1000; // 90 seconds in milliseconds
        const RAIN_DURATION_MS = 30 * 1000; // 30 seconds in milliseconds
        let lastFrameTime = Date.now(); // To calculate delta time for consistent rain movement
        let lightningFlash = 0; // Controls lightning flash intensity (0 to 1)

        let shakeIntensity = 0; // New variable for map shake intensity

        // Defined a shorter, more winding path
        const initialPath = [
            { x: 0.0, y: 0.2 },
            { x: 0.2, y: 0.1 },
            { x: 0.4, y: 0.3 },
            { x: 0.3, y: 0.5 },
            { x: 0.5, y: 0.7 },
            { x: 0.7, y: 0.6 },
            { x: 0.8, y: 0.8 },
            { x: 1.0, y: 0.7 }
        ];
        let currentPath = initialPath;

        let enemiesToSpawn = 0; // Total enemies for the current wave
        let enemiesSpawned = 0; // Enemies actually spawned from the queue

        // Game UI elements
        const moneyStat = document.getElementById('money-stat');
        const livesStat = document.getElementById('lives-stat');
        const waveStat = document.getElementById('wave-stat');
        const buyBasicTowerBtn = document.getElementById('buy-basic-tower');
        const buyKnightBtn = document.getElementById('buy-knight');
        const buyCannonTowerBtn = document.getElementById('buy-cannon-tower');
        const buyBombBtn = document.getElementById('buy-bomb'); // New bomb button reference
        const messageBox = document.getElementById('message-box');
        const statsOverlay = document.querySelector('.stats-overlay');


        const assets = {}; // Object to store loaded image assets

        // Function to load all game assets
        function loadAssets(callback) {
            const assetUrls = [
                { name: 'enemy', url: 'https://raw.githubusercontent.com/avelate/workshop/refs/heads/main/Untitled%20design.gif', type: 'image' },
                { name: 'tower', url: 'https://placehold.co/36x36/6e6e6e/ffffff?text=ARCHER', type: 'image' }, // Updated basic tower asset URL
                { name: 'arrow', url: 'https://placehold.co/40x10/8d6e63/ffffff.svg?text=%3E', type: 'image' }, // Used for basic tower projectiles
                { name: 'grassBackground', url: 'https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/db077959-031d-437f-8bcb-1465f5bd1a80/grass.png', type: 'image' },
                { name: 'knight', url: 'https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/2ee45746-ae42-414b-b85f-c8d57f99ecea/knight.png', type: 'image' },
                { name: 'pathTexture', url: 'https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/ccd0fde0-45ae-4a67-b939-0252444d0e71/stone.png', type: 'image' },
                { name: 'cannonTower', url: 'https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/2751daef-8137-44a9-be9c-6e3a196156e1/tower2.png', type: 'image' },
                { name: 'ogre', url: 'https://images.squarespace-cdn.com/content/624ef2c92ddf2d4875782bd1/e67884a3-2a91-4c3d-b97a-e4e0918cf043/ogre.png', type: 'image' },
                { name: 'bomb', url: 'https://placehold.co/36x36/000000/FFFFFF?text=üí£', type: 'image' } // Bomb asset URL
            ];

            const promises = assetUrls.map(asset => {
                return new Promise((resolve) => {
                    const element = new Image();
                    element.onload = () => {
                        assets[asset.name] = element;
                        resolve();
                    };
                    element.onerror = (e) => {
                        console.error(`Failed to load asset: ${asset.url}`, e);
                        resolve(); // Resolve even on error to not block game
                    };
                    element.src = asset.url;
                    element.classList.add('hidden-asset'); // Hide images from DOM
                    document.body.appendChild(element); // Append to body to ensure loading
                });
            });

            Promise.all(promises).then(() => {
                callback(); // All assets loaded, proceed to game initialization
            });
        }

        // Define the base resolution for scaling game elements
        const BASE_WIDTH = 1080;
        const BASE_HEIGHT = 2424;

        // Calculate a scaling factor for game elements based on the canvas width
        let currentScaleFactor = 1;

        // Configuration for different tower types
        const towerConfigs = {
            basic: {
                cost: 50,
                size: 90,
                range: 150,
                damage: 5 * 1.30, // Basic tower damage
                fireRate: 500, // Faster fire rate for basic tower
                isProjectile: true,
                asset: 'tower'
            },
            knight: {
                cost: 25,
                size: 70 * 0.7, // Smaller size for knight
                range: 40, // Melee range
                damage: ((5 * 1.30) * 1.5 * 1.25 * 4) * 0.25, // Adjusted damage for knight
                fireRate: 800, // Knight attack speed
                isProjectile: false,
                asset: 'knight',
                health: 67, // Knight health reduced by 50%
                maxHealth: 67,
                regenRate: 0.5 // Health regeneration per frame
            },
            cannonTower: {
                cost: 150,
                size: 90,
                range: 200,
                damage: (5 * 1.30) * 3 * 2, // High damage for cannon
                fireRate: 1500, // Slow fire rate for cannon
                isProjectile: true,
                asset: 'cannonTower'
            },
            bomb: { // New bomb configuration
                cost: 175, // Bomb cost 175 gold
                size: 10, // Placeholder size, explosion handles visual
                range: 150 * 1.5, // Increased bomb radius by 50%
                damage: ((5 * 1.30) * 3 * 2 * 9) * 1.5, // Cannonball damage * 9 * 1.5 (increased by 50%)
                isProjectile: false,
                asset: 'bomb' // Will be a temporary visual
            }
        };

        let messageTimeout;
        // Function to show a temporary message box
        function showMessage(text) {
            messageBox.textContent = text;
            messageBox.style.display = 'block';
            clearTimeout(messageTimeout);
            messageTimeout = setTimeout(() => {
                messageBox.style.display = 'none';
            }, 3000);
        }

        // Function to update the game stats in the UI
        function updateUI() {
            moneyStat.innerHTML = `üí∞<span>${money}</span>`;
            livesStat.innerHTML = `‚ù§Ô∏è<span>${lives}</span>`;
            waveStat.innerHTML = `üè∞<span>${wave}</span>`;
        }
        
        // Reset all game variables to their initial state
        function resetGame() {
            money = 100;
            lives = 20;
            wave = 0;
            gameActive = false;
            gameOver = false;
            placingTower = false;
            selectedTowerType = null;
            enemies = [];
            towers = [];
            projectiles = [];
            bombs = []; // Reset bombs array
            currentPath = initialPath; // Reset to the first map path
            enemiesToSpawn = 0;
            enemiesSpawned = 0;
            paused = false; // Reset paused state
            pauseButton.innerHTML = '<i class="fas fa-pause"></i>'; // Reset pause icon
            pauseButtonContainer.style.display = 'none'; // Hide pause button again on reset
            waveEndedProcessing = false; // Reset wave processing flag

            // Reset rainstorm variables
            raindrops = [];
            rainTimer = 0;
            rainActive = false;
            lastFrameTime = Date.now(); // Reset lastFrameTime for accurate delta calculation
            lightningFlash = 0; // Reset lightning flash

            shakeIntensity = 0; // Reset shake intensity

            waveCompleteModal.style.display = 'none';
            gameOverModal.style.display = 'none';
            buyBasicTowerBtn.classList.remove('active'); // Remove active state from buttons
            buyKnightBtn.classList.remove('active');
            buyCannonTowerBtn.classList.remove('active');
            buyBombBtn.classList.remove('active'); // Remove active state from bomb button
            
            spawnInitialTower(); // Place the free starting tower
            updateUI();
            drawBackground();
            drawPath();
        }

        // Spawn a free tower at the start of the game/map
        function spawnInitialTower() {
            const lastPathPoint = currentPath[currentPath.length - 1];
            // Position the initial tower relative to the canvas size, slightly offset from path end
            const initialTowerX = (lastPathPoint.x * canvas.width) - (100 * currentScaleFactor);
            const initialTowerY = (lastPathPoint.y * canvas.height) + (50 * currentScaleFactor);
            const initialTower = new Tower(initialTowerX, initialTowerY, 'basic');
            towers = [initialTower]; // Ensure only the initial tower is present on reset
            // Hide radius after a short delay
            setTimeout(() => {
                initialTower.showRadius = false;
            }, 3000);
        }
        
        // Enemy class definition
        class Enemy {
            constructor(waveNumber) {
                this.x = currentPath[0].x;
                this.y = currentPath[0].y;
                this.size = 50; // Base size, will be scaled in draw
                // Speed in fraction of canvas dimension per millisecond
                this.speed = (1 + waveNumber * 0.05) * (0.0008 / (1000 / 60)); // Original speed was 0.0008 per frame, convert to per ms
                this.health = 80 + waveNumber * 15; // Health increases with wave
                this.maxHealth = this.health;
                this.pathIndex = 0; // Current point on the path
                this.verticalOffset = 0; // For bobbing animation
                this.isStunned = false;
                this.stunTimer = 0; // Frames remaining for stun
                this.isDying = false;
                this.deathAnimationProgress = 0;
                this.deathAnimationDuration = 30; // frames, made faster
                this.asset = 'enemy'; // Default asset for regular enemies (orcs)
                this.meleeDamage = 5; // Orcs deal 5 damage to knights
                this.attackRange = 50; // Range for melee attack
                this.attackCooldown = 192; // Twice as slow as knight attacks (800ms knight / 1000ms * 60fps * 4 = 192 frames)
                this.lastAttackTime = 0;

                this.isAttacking = false; // For attack animation
                this.attackAnimationProgress = 0; // 0 to 1
                this.attackAnimationDuration = 15; // frames for the animation

                // Enemy regeneration rate (15% of knight's regen rate)
                this.regenRate = towerConfigs.knight.regenRate * 0.15;
            }

            draw() {
                const drawX = this.x * canvas.width;
                const drawY = this.y * canvas.height + this.verticalOffset;
                let drawSize = this.size * currentScaleFactor; // Apply scaling here

                // Apply death animation effects (fading and shrinking)
                if (this.isDying) {
                    ctx.globalAlpha = 1 - this.deathAnimationProgress; // Fade out
                    drawSize *= (1 - this.deathAnimationProgress * 0.5); // Shrink slightly
                } else if (this.isAttacking) { // Apply attack animation if not dying
                    this.attackAnimationProgress += 1 / this.attackAnimationDuration;
                    if (this.attackAnimationProgress >= 1) {
                        this.isAttacking = false;
                        this.attackAnimationProgress = 0;
                    }
                    // Apply a more pronounced scale effect during attack
                    const scaleFactor = 1 + Math.sin(this.attackAnimationProgress * Math.PI) * 0.2; // More pronounced bounce
                    drawSize *= scaleFactor;

                    // Add a temporary red flash effect
                    ctx.save();
                    ctx.globalAlpha = (1 - this.attackAnimationProgress) * 0.7; // Fade out
                    ctx.fillStyle = 'red';
                    ctx.beginPath();
                    ctx.arc(drawX, drawY, drawSize * 0.6, 0, Math.PI * 2); // Red circle around enemy
                    ctx.fill();
                    ctx.restore();
                }
                
                // Draw a subtle shadow under the enemy
                ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 3;
                ctx.shadowOffsetY = 3;

                const currentAsset = assets[this.asset]; // Use the specific asset for this enemy type
                if (currentAsset && currentAsset.complete) { 
                    ctx.drawImage(currentAsset, drawX - drawSize / 2, drawY - drawSize / 2, drawSize, drawSize);
                } else {
                    // Fallback if asset fails to load
                    ctx.fillStyle = this.asset === 'enemy' ? 'red' : 'purple';
                    ctx.fillRect(drawX - drawSize / 2, drawY - drawSize / 2, drawSize, drawSize);
                }
                
                ctx.shadowColor = 'transparent'; // Reset shadow after drawing enemy
                ctx.globalAlpha = 1; // Reset global alpha after drawing enemy

                // Draw health bar if not dying
                if (!this.isDying) {
                    const healthBarWidth = drawSize;
                    const healthPercentage = this.health / this.maxHealth;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(drawX - healthBarWidth / 2, drawY - drawSize, healthBarWidth, 5 * currentScaleFactor); // Scaled health bar height
                    ctx.fillStyle = 'green';
                    ctx.fillRect(drawX - healthBarWidth / 2, drawY - drawSize, healthBarWidth * healthPercentage, 5 * currentScaleFactor);
                }
            }

            update(deltaTime) { // Pass deltaTime to update method
                if (this.isDying) {
                    this.deathAnimationProgress += 1 / this.deathAnimationDuration;
                    return;
                }
                if (this.isStunned) {
                    this.stunTimer--;
                    if (this.stunTimer <= 0) {
                        this.isStunned = false;
                    }
                    return; // Stunned enemies do not move
                }

                const now = Date.now();
                
                // Check for nearby knights to attack (melee)
                for (const tower of towers) {
                    if (tower.type === 'knight') {
                        const knightX = tower.x;
                        const knightY = tower.y;
                        const enemyDrawX = this.x * canvas.width;
                        const enemyDrawY = this.y * canvas.height;
                        const dist = Math.sqrt((enemyDrawX - knightX) ** 2 + (knightY - enemyDrawY) ** 2); // Corrected Y-coordinate for distance calculation

                        if (dist <= this.attackRange * currentScaleFactor) { // Scale attack range
                            if (now - this.lastAttackTime > this.attackCooldown) {
                                tower.health -= this.meleeDamage; // Apply damage to knights
                                this.lastAttackTime = now;
                                this.isAttacking = true; // Trigger attack animation
                                this.attackAnimationProgress = 0;
                            }
                            // Do NOT return here, allow enemy to continue moving even while attacking
                            // unless they are directly on top of the knight.
                            // For simplicity, we let them move past if they are not stuck.
                        }
                    }
                }
                
                // If enemy reached end of path, do nothing further (will be removed by game loop)
                if (this.pathIndex + 1 >= currentPath.length) {
                    return;
                }

                // Move towards next path point
                const targetX = currentPath[this.pathIndex + 1].x;
                const targetY = currentPath[this.pathIndex + 1].y;

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < this.speed * deltaTime) { // Use deltaTime for consistent movement
                    this.x = targetX;
                    this.y = targetY;
                    this.pathIndex++;
                } else {
                    this.x += (dx / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                    this.y += (dy / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                }
                
                // Add a slight bobbing animation to the enemy
                this.verticalOffset = Math.sin(Date.now() / 100) * 2 * currentScaleFactor; // Scaled bobbing

                // Health regeneration for enemies
                if (this.health < this.maxHealth) {
                    this.health = Math.min(this.maxHealth, this.health + this.regenRate);
                }
            }
        }

        // New Ogre class, extending Enemy
        class Ogre extends Enemy {
            constructor(waveNumber) {
                super(waveNumber); // Call parent constructor to inherit base properties
                this.size = 50 * 1.5; // 50% larger than orc (base size 50), will be scaled in draw
                // Speed in fraction of canvas dimension per millisecond
                this.speed = ((1 + waveNumber * 0.05) * (0.0008 / (1000 / 60))) / 2; // Twice as slow as regular enemies
                this.health = (80 + waveNumber * 15) * 5; // 5 times health
                this.maxHealth = this.health; // Update maxHealth for health bar
                this.asset = 'ogre'; // Use the ogre asset
                this.meleeDamage = 10; // Ogres deal 10 damage to knights
                this.attackCooldown = 192; // Ogres attack at half the speed of knights
                // Ogre also regenerates health at the same rate as other enemies
            }
            // No need to override draw or update as they are generic enough in parent
        }

        // Tower class definition (now handles basic towers, knights, and cannon towers)
        class Tower {
            constructor(x, y, type) {
                const config = towerConfigs[type];
                this.x = x;
                this.y = y;
                this.type = type; // Store the type (basic, knight, cannonTower)
                this.size = config.size; // Base size, will be scaled in draw
                this.range = config.range; // Base range, will be scaled in update
                this.damage = config.damage;
                this.fireRate = config.fireRate;
                this.lastFired = 0;
                this.showRadius = true; // Show range circle when placed
                this.animationStartTime = Date.now(); // For placement animation
                this.animationDuration = 500;
                this.asset = config.asset; // Store the asset name
                this.isAttacking = false; // For knight attack animation
                this.attackFrame = 0; // For knight attack animation progress
                this.attackDuration = 10; // frames for knight attack animation

                // Health and regeneration for knights
                if (this.type === 'knight') {
                    this.health = config.health;
                    this.maxHealth = config.maxHealth;
                    this.regenRate = config.regenRate;
                }
            }

            draw() {
                const elapsedTime = Date.now() - this.animationStartTime;
                let scale = 1;
                // Add a small bounce animation when the tower is placed
                if (elapsedTime < this.animationDuration) {
                    const progress = elapsedTime / this.animationDuration;
                    scale = 1 + Math.sin(progress * Math.PI) * 0.1;
                }

                const drawSize = this.size * currentScaleFactor * scale; // Apply scaling here
                const assetImage = assets[this.asset];

                if (assetImage && assetImage.complete) {
                    // Draw a subtle shadow for all towers/knights
                    ctx.shadowColor = 'rgba(0, 0, 0, 0.3)';
                    ctx.shadowBlur = 5;
                    ctx.shadowOffsetX = 3;
                    ctx.shadowOffsetY = 3;

                    ctx.save();
                    ctx.translate(this.x, this.y);
                    if (this.type === 'knight' && this.isAttacking) {
                        this.attackFrame++;
                        // Make the rotation more pronounced for the attack animation
                        const maxRotation = Math.PI / 6; // 30 degrees
                        if (this.attackFrame <= this.attackDuration / 2) {
                            // Swing forward
                            ctx.rotate(maxRotation * (this.attackFrame / (this.attackDuration / 2)));
                        } else if (this.attackFrame <= this.attackDuration) {
                            // Swing back
                            ctx.rotate(maxRotation * (1 - ((this.attackFrame - this.attackDuration / 2) / (this.attackDuration / 2))));
                        } else {
                            this.isAttacking = false;
                            this.attackFrame = 0;
                        }
                    }
                    ctx.drawImage(assetImage, -drawSize / 2, -drawSize / 2, drawSize, drawSize);
                    ctx.restore();
                    
                    ctx.shadowColor = 'transparent'; // Reset shadow after drawing
                }

                // Show the range circle for a few seconds after placing (only for projectile towers)
                if(this.showRadius && (this.type === 'basic' || this.type === 'cannonTower')) {
                    const radiusElapsedTime = Date.now() - this.animationStartTime;
                    const radiusProgress = radiusElapsedTime / 3000; // Fade out over 3 seconds
                    if (radiusProgress < 1) {
                        ctx.strokeStyle = `rgba(255, 255, 255, ${1 - radiusProgress})`; // White color, fading
                        ctx.lineWidth = 3 * currentScaleFactor; // Thicker line, scaled
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.range * currentScaleFactor, 0, Math.PI * 2); // Scale range
                        ctx.stroke();
                    } else {
                        this.showRadius = false;
                    }
                }

                // Draw health bar for knights
                if (this.type === 'knight') {
                    const healthBarWidth = drawSize;
                    const healthPercentage = this.health / this.maxHealth;
                    ctx.fillStyle = 'red';
                    ctx.fillRect(this.x - healthBarWidth / 2, this.y - drawSize / 2 - (10 * currentScaleFactor), healthBarWidth, 5 * currentScaleFactor); // Scaled health bar position and height
                    ctx.fillStyle = 'green';
                    ctx.fillRect(this.x - healthBarWidth / 2, this.y - drawSize / 2 - (10 * currentScaleFactor), healthBarWidth * healthPercentage, 5 * currentScaleFactor);
                }
            }

            update(enemies) {
                const now = Date.now();
                
                // Knight health regeneration
                if (this.type === 'knight' && this.health < this.maxHealth) {
                    this.health = Math.min(this.maxHealth, this.health + this.regenRate);
                }

                // Check if enough time has passed to fire/attack again
                if (now - this.lastFired > this.fireRate) {
                    const unitX = this.x;
                    const unitY = this.y;
                    
                    // Find a target enemy within range
                    const targetEnemy = enemies.find(enemy => {
                        const enemyX = enemy.x * canvas.width;
                        const enemyY = enemy.y * canvas.height;
                        const dist = Math.sqrt((unitX - enemyX) ** 2 + (unitY - enemyY) ** 2);
                        return dist <= this.range * currentScaleFactor; // Use scaled range for targeting
                    });

                    if (targetEnemy) {
                        if (this.type === 'basic') {
                            // Basic tower fires an arrow (Bolt)
                            projectiles.push(new Bolt(unitX, unitY, targetEnemy, this.damage, this.range));
                        } else if (this.type === 'knight') {
                            // Knights deal damage directly when in range (melee attack)
                            targetEnemy.health -= this.damage;
                            this.isAttacking = true; // Trigger attack animation
                            this.attackFrame = 0;
                            // Knight stuns enemy for 1 second (60 frames)
                            targetEnemy.isStunned = true;
                            targetEnemy.stunTimer = 60;
                        } else if (this.type === 'cannonTower') {
                            // Cannon tower fires a cannonball
                            projectiles.push(new Cannonball(unitX, unitY, targetEnemy, this.damage, this.range));
                        }
                        this.lastFired = now; // Reset fire timer
                    }
                }
            }
        }

        // Projectile class for basic tower (arrows)
        class Bolt {
            constructor(x, y, target, damage, towerRange) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                // Speed in pixels per millisecond
                this.speed = (5 / (1000 / 60)); // Original speed was 5 pixels per frame, convert to per ms
                this.size = { width: 40 * 0.5, height: 10 * 0.5 }; // Decreased size by 50%
                this.angle = 0;
                this.trail = [];
                this.maxTrailLength = 5; // For motion blur effect
                this.originX = x; // Store origin for range check
                this.originY = y; // Store origin for range check
                this.maxRange = towerRange; // Store tower's range
            }

            draw() {
                // Draw the trail with decreasing opacity for the blur effect
                for (let i = 0; i < this.trail.length; i++) {
                    const trailPoint = this.trail[i];
                    const alpha = (i + 1) / this.trail.length;
                    ctx.save();
                    ctx.translate(trailPoint.x, trailPoint.y);
                    ctx.rotate(trailPoint.angle);
                    ctx.globalAlpha = alpha * 0.5; // Soft blur effect
                    const arrowImage = assets.arrow;
                    if (arrowImage && arrowImage.complete) {
                        ctx.drawImage(arrowImage, -(this.size.width / 2) * currentScaleFactor, -(this.size.height / 2) * currentScaleFactor, this.size.width * currentScaleFactor, this.size.height * currentScaleFactor);
                    } else {
                        ctx.fillStyle = '#6e6e6e'; // Fallback color
                        ctx.fillRect(-(this.size.width / 2) * currentScaleFactor, -(this.size.height / 2) * currentScaleFactor, this.size.width * currentScaleFactor, this.size.height * currentScaleFactor);
                    }
                    ctx.restore();
                }

                // Draw the main projectile on top of the trail
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.angle);
                ctx.globalAlpha = 1; // Full opacity for the main projectile
                const arrowImage = assets.arrow;
                if (arrowImage && arrowImage.complete) {
                    ctx.drawImage(arrowImage, -(this.size.width / 2) * currentScaleFactor, -(this.size.height / 2) * currentScaleFactor, this.size.width * currentScaleFactor, this.size.height * currentScaleFactor);
                    } else {
                        ctx.fillStyle = '#6e6e6e';
                        ctx.fillRect(-(this.size.width / 2) * currentScaleFactor, -(this.size.height / 2) * currentScaleFactor, this.size.width * currentScaleFactor, this.size.height * currentScaleFactor);
                    }
                    ctx.restore();
                }

                update(deltaTime) { // Pass deltaTime to update method
                    // Check if projectile has traveled beyond tower's max range
                    const currentTravelDistance = Math.sqrt((this.x - this.originX)**2 + (this.y - this.originY)**2);
                    if (currentTravelDistance > this.maxRange * currentScaleFactor) {
                        return false; // Disappear if too far
                    }

                    // If target is invalid or dead, remove projectile
                    if (!this.target || this.target.health <= 0) {
                        return false;
                    }

                    const targetX = this.target.x * canvas.width;
                    const targetY = this.target.y * canvas.height;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // Calculate the angle for rotation
                    this.angle = Math.atan2(dy, dx);
                    
                    // Add the current position to the trail and limit its length
                    this.trail.push({ x: this.x, y: this.y, angle: this.angle });
                    if (this.trail.length > this.maxTrailLength) {
                        this.trail.shift();
                    }

                    if (distance <= this.speed * deltaTime) { // Use deltaTime for consistent movement
                        // Apply damage and a chance to stun when hitting the target
                        this.target.health -= this.damage;
                        if (Math.random() < 0.25) { // 25% chance to stun
                            this.target.isStunned = true;
                            this.target.stunTimer = 60; // Stun for 1 second (60 frames)
                        }
                        return false; // Projectile hit, remove it
                    } else {
                        // Move the bolt in a straight line
                        this.x += (dx / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                        this.y += (dy / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                        return true; // Projectile is still active
                    }
                }
            }

            // New Cannonball class (for cannon towers)
            class Cannonball {
                constructor(x, y, target, damage, towerRange) {
                    this.x = x;
                    this.y = y;
                    this.target = target;
                    this.damage = damage;
                    // Speed in pixels per millisecond
                    this.speed = (5 / (1000 / 60)); // Original speed was 5 pixels per frame, convert to per ms
                    this.radius = 4; // Base radius, will be scaled in draw
                    this.isExploding = false; // Flag for explosion animation
                    this.explosionFrame = 0;
                    this.explosionDuration = 15; // frames for explosion animation
                    this.originX = x; // Store origin for range check
                    this.originY = y; // Store origin for range check
                    this.maxRange = towerRange; // Store tower's range
                }

                draw() {
                    if (this.isExploding) {
                        const alpha = 1 - (this.explosionFrame / this.explosionDuration);
                        const currentRadius = (this.radius + (this.explosionFrame * 2)) * currentScaleFactor; // Scale radius
                        ctx.fillStyle = `rgba(100, 100, 100, ${alpha})`; // Gray color, fading
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                        ctx.fill();
                    } else {
                        ctx.fillStyle = '#6e6e6e'; // Gray cannonball
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius * currentScaleFactor, 0, Math.PI * 2); // Scale radius
                        ctx.fill();
                    }
                }

                update(deltaTime) { // Pass deltaTime to update method
                    // If exploding, advance explosion animation
                    if (this.isExploding) {
                        this.explosionFrame++;
                        return this.explosionFrame < this.explosionDuration; // Keep alive until explosion is done
                    }

                    // Check if projectile has traveled beyond tower's max range
                    const currentTravelDistance = Math.sqrt((this.x - this.originX)**2 + (this.y - this.originY)**2);
                    if (currentTravelDistance > this.maxRange * currentScaleFactor) {
                        this.isExploding = true; // Explode if too far
                        return true; // Keep alive for explosion animation
                    }

                    // If target is invalid or dead, start explosion at current position
                    if (!this.target || this.target.health <= 0) {
                        this.isExploding = true;
                        return true; // Still active for explosion animation
                    }

                    const targetX = this.target.x * canvas.width;
                    const targetY = this.target.y * canvas.height;

                    const dx = targetX - this.x;
                    const dy = targetY - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    if (distance <= this.speed * deltaTime) { // Use deltaTime for consistent movement
                        this.target.health -= this.damage; // Apply damage
                        this.isExploding = true; // Start explosion animation
                        return true; // Keep alive for explosion animation
                    } else {
                        // Move the cannonball in a straight line
                        this.x += (dx / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                        this.y += (dy / distance) * this.speed * deltaTime; // Use deltaTime for consistent movement
                        return true; // Still moving
                    }
                }
            }

            // New Bomb class
            class Bomb {
                constructor(x, y, damage, radius) {
                    this.x = x;
                    this.y = y;
                    this.damage = damage;
                    this.radius = radius;
                    this.isExploding = true; // Bomb explodes immediately on creation
                    this.explosionFrame = 0;
                    this.explosionDuration = 75; // Frames for explosion animation (slower: 60 * 1.25 = 75)
                    this.hasDealtDamage = false;

                    this.isFlaming = false;
                    this.flameFrame = 0;
                    this.flameDuration = 120; // 2 seconds * 60 frames/sec = 120 frames
                }

                draw() {
                    if (this.isExploding) {
                        const alpha = 1 - (this.explosionFrame / this.explosionDuration);
                        const currentRadius = (this.radius * currentScaleFactor) * (this.explosionFrame / this.explosionDuration) * 1.5; // Grow and fade
                        
                        ctx.fillStyle = `rgba(255, 165, 0, ${alpha})`; // Orange/Yellow fading
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, currentRadius, 0, Math.PI * 2);
                        ctx.fill();

                        ctx.strokeStyle = `rgba(255, 255, 0, ${alpha})`; // Yellow outline
                        ctx.lineWidth = 5 * currentScaleFactor;
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, currentRadius * 0.8, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (this.isFlaming) {
                        const alpha = 1 - (this.flameFrame / this.flameDuration);
                        // Draw multiple small red/orange circles around the center
                        for (let i = 0; i < 5; i++) { // 5 small flames
                            const flameRadius = (5 + Math.sin(this.flameFrame / 5 + i) * 3) * currentScaleFactor; // Pulsating effect
                            const offsetX = Math.sin(i * Math.PI / 2.5 + this.flameFrame / 10) * (this.radius * 0.5 * currentScaleFactor);
                            const offsetY = Math.cos(i * Math.PI / 2.5 + this.flameFrame / 10) * (this.radius * 0.5 * currentScaleFactor);
                            
                            ctx.fillStyle = `rgba(255, ${100 + Math.random() * 100}, 0, ${alpha})`; // Reddish-orange
                            ctx.beginPath();
                            ctx.arc(this.x + offsetX, this.y + offsetY, flameRadius, 0, Math.PI * 2);
                            ctx.fill();
                        }
                    }
                }

                update() {
                    if (this.isExploding) {
                        if (!this.hasDealtDamage) {
                            // Apply damage to all enemies within radius
                            enemies.forEach(enemy => {
                                const enemyX = enemy.x * canvas.width;
                                const enemyY = enemy.y * canvas.height;
                                const dist = Math.sqrt((this.x - enemyX) ** 2 + (this.y - enemyY) ** 2);
                                if (dist <= this.radius * currentScaleFactor) {
                                    enemy.health -= this.damage;
                                }
                            });
                            this.hasDealtDamage = true;
                            // Trigger map shake
                            shakeIntensity = 10; // Max shake intensity
                        }

                        this.explosionFrame++;
                        if (this.explosionFrame >= this.explosionDuration) {
                            this.isExploding = false;
                            this.isFlaming = true; // Transition to flaming state
                        }
                        return true; // Keep alive during explosion
                    } else if (this.isFlaming) {
                        this.flameFrame++;
                        return this.flameFrame < this.flameDuration; // Keep alive during flaming
                    }
                    return false; // Remove when done flaming
                }
            }

            // --- Drawing functions ---
            function drawPath() {
                // Draw tiled path texture
                if (assets.pathTexture && assets.pathTexture.complete) {
                    // Create a temporary canvas to scale the image for the pattern
                    const tempCanvas = document.createElement('canvas');
                    const tempCtx = tempCanvas.getContext('2d');
                    tempCanvas.width = 50 * currentScaleFactor; // Desired scaled width for one tile
                    tempCanvas.height = 50 * currentScaleFactor; // Desired scaled height for one tile
                    tempCtx.drawImage(assets.pathTexture, 0, 0, tempCanvas.width, tempCanvas.height); // Draw image scaled
                    
                    const pattern = ctx.createPattern(tempCanvas, 'repeat');
                    ctx.strokeStyle = pattern; // Use the pattern for the stroke style
                    ctx.globalAlpha = 0.6; // Make the path more visible
                } else {
                    ctx.strokeStyle = '#b0b0b0'; // Fallback color
                    ctx.globalAlpha = 1;
                }
                ctx.lineWidth = 50 * currentScaleFactor; // Adjust line width to match scaled tile size
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(currentPath[0].x * canvas.width, currentPath[0].y * canvas.height);
                for (let i = 1; i < currentPath.length; i++) {
                    ctx.lineTo(currentPath[i].x * canvas.width, currentPath[i].y * canvas.height);
                }
                ctx.stroke();
                ctx.globalAlpha = 1; // Reset globalAlpha after drawing path
            }

            function drawBackground() {
                // Draw tiled grass background
                if (assets.grassBackground && assets.grassBackground.complete) {
                    const pattern = ctx.createPattern(assets.grassBackground, 'repeat');
                    ctx.fillStyle = pattern;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                } else {
                    ctx.fillStyle = '#8bc34a'; // Fallback green color
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                }
            }

            // --- Game Logic ---
            function spawnWave() {
                wave++;
                enemiesToSpawn = wave * 3 + 2; // Total enemies for the wave
                enemiesSpawned = 0; // Reset count for this wave

                for (let i = 0; i < enemiesToSpawn; i++) {
                    const delay = i * (1000 + Math.random() * 500); // Stagger enemy spawning
                    setTimeout(() => {
                        if (!gameOver && gameActive) { // Only spawn if game is active and not over
                            if (wave >= 5 && Math.random() < 0.3) { // 30% chance to spawn an ogre from wave 5
                                enemies.push(new Ogre(wave));
                            } else {
                                enemies.push(new Enemy(wave)); // Orc (regular enemy)
                            }
                            enemiesSpawned++;
                        }
                    }, delay);
                }
            }

            function checkGameOver() {
                if (lives <= 0) {
                    gameOver = true;
                    gameActive = false; // Stop game logic
                    buyBasicTowerBtn.style.display = 'none';
                    buyKnightBtn.style.display = 'none';
                    buyCannonTowerBtn.style.display = 'none';
                    buyBombBtn.style.display = 'none'; // Hide bomb button on game over
                    pauseButtonContainer.style.display = 'none'; // Hide pause button on game over
                    waveCompleteModal.style.display = 'none'; // Hide wave complete modal if visible
                    
                    document.getElementById('final-wave').textContent = wave - 1; // Show waves survived
                    gameOverModal.style.display = 'block'; // Show game over modal
                }
            }
            
            function checkWaveEnd() {
                // Check if all enemies that were supposed to spawn have spawned AND all spawned enemies are gone
                if (enemies.length === 0 && enemiesSpawned >= enemiesToSpawn && wave > 0 && !waveEndedProcessing) {
                    waveEndedProcessing = true; // Set flag to true to prevent re-entry
                    gameActive = false; // Stop game loop logic (enemies stop moving, towers stop firing)
                    
                    // Apply gold based on wave completion
                    let bonusMessage = "";
                    if (wave === 1) {
                        money = 150; // Exactly 150 at start of round 2 (after wave 1 ends)
                        bonusMessage = "Wave 1 complete! Bonus: 75 gold. Total gold: 150.";
                    } else if (wave === 2) {
                        money = 200; // Exactly 200 at start of round 3 (after wave 2 ends)
                        bonusMessage = "Wave 2 complete! Bonus: 50 gold. Total gold: 200.";
                    } else {
                        money += 75; // Regular 75 gold bonus for other waves
                        bonusMessage = `Wave ${wave} complete! Bonus: 75 gold. Total gold: ${money}.`;
                    }
                    showMessage(bonusMessage);

                    // Clear enemies and projectiles for the next wave
                    enemies = [];
                    projectiles = [];
                    bombs = []; // Clear bombs array
                    enemiesSpawned = 0; // Reset for next wave
                    enemiesToSpawn = 0; // Reset for next wave

                    updateUI(); // Update UI to show new gold
                    
                    // Show the wave complete modal, user must click to proceed
                    waveCompleteModal.style.display = 'block';
                }
            }

            // Main game loop
            let animationFrameId;
            function gameLoop() {
                const now = Date.now();
                const deltaTime = now - lastFrameTime; // Calculate time elapsed since last frame
                lastFrameTime = now; // Update lastFrameTime for the next iteration

                // Rainstorm timing logic
                if (!paused && !gameOver && gameActive) { // Only update rain timer if game is active
                    if (!rainActive) {
                        rainTimer += deltaTime;
                        if (rainTimer >= RAIN_INTERVAL_MS) {
                            rainActive = true;
                            rainTimer = RAIN_DURATION_MS; // Use rainTimer to count down duration
                            // Initialize raindrops
                            raindrops = [];
                            for (let i = 0; i < 200; i++) { // Number of raindrops
                                raindrops.push({
                                    x: Math.random() * canvas.width,
                                    y: Math.random() * canvas.height,
                                    length: 10 + Math.random() * 10,
                                    speed: 0.2 + Math.random() * 0.3 // Slower speed for rain
                                });
                            }
                        }
                    } else { // If it is raining
                        rainTimer -= deltaTime;
                        if (rainTimer <= 0) {
                            rainActive = false;
                            rainTimer = 0; // Reset for next interval countdown
                            raindrops = []; // Clear raindrops
                            lightningFlash = 0; // Ensure lightning stops
                        } else {
                            // Subtle lightning effect during rain
                            if (Math.random() < 0.005) { // Small chance for a flash
                                lightningFlash = 0.2 + Math.random() * 0.3; // Random intensity
                            }
                            lightningFlash = Math.max(0, lightningFlash - 0.01); // Fade out
                        }
                    }
                }

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Apply map shake if active
                if (shakeIntensity > 0) {
                    const shakeX = (Math.random() - 0.5) * shakeIntensity * currentScaleFactor;
                    const shakeY = (Math.random() - 0.5) * shakeIntensity * currentScaleFactor;
                    ctx.translate(shakeX, shakeY);
                    shakeIntensity = Math.max(0, shakeIntensity - 0.5); // Reduce shake over time
                }

                // If paused or game over, just draw the current state without updating game elements
                if (gameOver || paused) {
                    drawBackground();
                    drawPath();
                    // Draw rain even if paused/game over, but not if rainActive is false
                    if (rainActive) {
                        ctx.save();
                        // Darken the map
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Subtle darkening
                        ctx.fillRect(0, 0, canvas.width, canvas.height);

                        ctx.strokeStyle = 'rgba(173, 216, 230, 0.7)'; // Light blue, semi-transparent
                        ctx.lineWidth = 1 * currentScaleFactor;
                        for (let i = raindrops.length - 1; i >= 0; i--) {
                            const drop = raindrops[i];
                            // Only update rain position if not paused
                            if (!paused) {
                                drop.y += (drop.speed * currentScaleFactor * deltaTime);
                                drop.x += (0.05 * currentScaleFactor * deltaTime); // Slight horizontal drift
                            }

                            if (drop.y > canvas.height + drop.length || drop.x > canvas.width + drop.length) {
                                drop.y = Math.random() * -canvas.height; // Reset to top
                                drop.x = Math.random() * canvas.width; // Random X
                            }
                            ctx.beginPath();
                            ctx.moveTo(drop.x, drop.y);
                            ctx.lineTo(drop.x + drop.length * 0.5 * currentScaleFactor, drop.y + drop.length * currentScaleFactor); // Slanted rain
                            ctx.stroke();
                        }
                        ctx.restore();

                        // Draw lightning flash
                        if (lightningFlash > 0) {
                            ctx.fillStyle = `rgba(255, 255, 255, ${lightningFlash})`;
                            ctx.fillRect(0, 0, canvas.width, canvas.height);
                        }
                    }

                    // Combine enemies and towers into one array for sorting
                    const allDrawableEntitiesPaused = [];
                    enemies.forEach(enemy => allDrawableEntitiesPaused.push({ type: 'enemy', entity: enemy, drawY: enemy.y * canvas.height }));
                    towers.forEach(tower => allDrawableEntitiesPaused.push({ type: 'tower', entity: tower, drawY: tower.y }));

                    // Sort all entities by their effective Y coordinate for drawing order
                    allDrawableEntitiesPaused.sort((a, b) => a.drawY - b.drawY);

                    // Draw all entities in sorted order
                    allDrawableEntitiesPaused.forEach(item => item.entity.draw());

                    projectiles.forEach(p => p.draw());
                    bombs.forEach(b => b.draw()); // Draw bombs after everything else for explosion visibility

                    updateUI();
                    // Reset canvas transform after all drawing is done for this frame
                    ctx.setTransform(1, 0, 0, 1, 0, 0);
                    animationFrameId = requestAnimationFrame(gameLoop); // Keep drawing even when paused
                    return; // Exit loop if not active
                }

                drawBackground();
                drawPath();

                // Draw and update rain
                if (rainActive) {
                    ctx.save();
                    // Darken the map
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.2)'; // Subtle darkening
                    ctx.fillRect(0, 0, canvas.width, canvas.height);

                    ctx.strokeStyle = 'rgba(173, 216, 230, 0.7)'; // Light blue, semi-transparent
                    ctx.lineWidth = 1 * currentScaleFactor;
                    for (let i = raindrops.length - 1; i >= 0; i--) {
                        const drop = raindrops[i];
                        drop.y += (drop.speed * currentScaleFactor * deltaTime); // Scale speed by delta time
                        drop.x += (0.05 * currentScaleFactor * deltaTime); // Slight horizontal drift

                        if (drop.y > canvas.height + drop.length || drop.x > canvas.width + drop.length) {
                            drop.y = Math.random() * -canvas.height; // Reset to top
                            drop.x = Math.random() * canvas.width; // Random X
                        }
                        ctx.beginPath();
                        ctx.moveTo(drop.x, drop.y);
                        ctx.lineTo(drop.x + drop.length * 0.5 * currentScaleFactor, drop.y + drop.length * currentScaleFactor); // Slanted rain
                        ctx.stroke();
                    }
                    ctx.restore();

                    // Draw lightning flash
                    if (lightningFlash > 0) {
                        ctx.fillStyle = `rgba(255, 255, 255, ${lightningFlash})`;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                    }
                }

                // Update enemies (no drawing here)
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    enemy.update(deltaTime); // Pass deltaTime to enemy update
                    // Remove enemy if death animation is complete
                    if (enemy.isDying && enemy.deathAnimationProgress >= 1) {
                        enemies.splice(i, 1);
                    } 
                    // Remove enemy and reduce lives if it reaches the end of the path
                    else if (enemy.pathIndex >= currentPath.length - 1) {
                        lives--;
                        enemies.splice(i, 1);
                    } 
                    // Start death animation if health drops to 0 or below
                    else if (enemy.health <= 0 && !enemy.isDying) {
                        enemy.isDying = true;
                        // Check if the enemy is an Ogre to award triple money
                        if (enemy instanceof Ogre) {
                            money += (10 + wave) * 3; // Triple money for Ogres
                        } else {
                            money += 10 + wave; // Regular money for Orcs
                        }
                    }
                }

                // Update towers (includes knights now)
                // Filter out dead knights
                towers = towers.filter(tower => {
                    if (tower.type === 'knight' && tower.health <= 0) {
                        return false; // Remove dead knight
                    }
                    return true;
                });

                towers.forEach(tower => {
                    tower.update(enemies); // Tower update doesn't need deltaTime directly for its own logic
                });

                // Update projectiles (no drawing here)
                projectiles = projectiles.filter(p => p.update(deltaTime));

                // Update bombs (no drawing here)
                bombs = bombs.filter(b => b.update());

                // --- Drawing order: Draw elements sorted by Y coordinate ---
                const allDrawableEntities = [];
                enemies.forEach(enemy => allDrawableEntities.push({ type: 'enemy', entity: enemy, drawY: enemy.y * canvas.height }));
                towers.forEach(tower => allDrawableEntities.push({ type: 'tower', entity: tower, drawY: tower.y }));

                allDrawableEntities.sort((a, b) => a.drawY - b.drawY);

                allDrawableEntities.forEach(item => item.entity.draw());

                projectiles.forEach(p => p.draw());
                bombs.forEach(b => b.draw()); // Draw bombs after everything else for explosion visibility

                updateUI();
                checkGameOver();
                checkWaveEnd();

                // Reset canvas transform after all drawing is done for this frame
                ctx.setTransform(1, 0, 0, 1, 0, 0);

                animationFrameId = requestAnimationFrame(gameLoop);
            }

            // --- Event Listeners ---
            // Event listener for "Play Again" button on Game Over modal
            playAgainBtn.addEventListener('click', () => {
                resetGame(); // Reset all game state
                // After reset, show the intro screen again
                howToPlayScreen.style.display = 'flex';
                // No need to call requestAnimationFrame here, as it will be called after the intro screen
            });

            // Event listener for "Charge to the Next Wave" button on Wave Complete modal
            nextWaveBtn.addEventListener('click', () => {
                waveCompleteModal.style.display = 'none'; // Hide the modal
                gameActive = true; // Re-activate game logic
                spawnWave(); // Start the next wave
                showMessage(`Wave ${wave} incoming!`);
                waveEndedProcessing = false; // Reset flag for next wave end
                requestAnimationFrame(gameLoop); // Ensure game loop is running
            });

            // Event listener for buying Basic Tower
            buyBasicTowerBtn.addEventListener('click', () => {
                if (money >= towerConfigs.basic.cost) {
                    placingTower = true;
                    selectedTowerType = 'basic';
                    buyBasicTowerBtn.classList.add('active');
                    // Remove active class from other buttons
                    buyKnightBtn.classList.remove('active');
                    buyCannonTowerBtn.classList.remove('active');
                    buyBombBtn.classList.remove('active'); // Remove active state from bomb button
                    showMessage(`Place thy fortress upon the grass!`);
                } else {
                    showMessage("Thou hast not enough coin!");
                }
            });

            // Event listener for the Knight button
            buyKnightBtn.addEventListener('click', () => {
                if (money >= towerConfigs.knight.cost) {
                    placingTower = true;
                    selectedTowerType = 'knight';
                    buyKnightBtn.classList.add('active');
                    // Remove active class from other buttons
                    buyBasicTowerBtn.classList.remove('active');
                    buyCannonTowerBtn.classList.remove('active');
                    buyBombBtn.classList.remove('active'); // Remove active state from bomb button
                    showMessage(`Place thy valiant knight upon the path!`);
                } else {
                    showMessage("Thou hast not enough coin for a knight!");
                }
            });

            // Event listener for the new Cannon Tower button
            buyCannonTowerBtn.addEventListener('click', () => {
                if (money >= towerConfigs.cannonTower.cost) {
                    placingTower = true;
                    selectedTowerType = 'cannonTower';
                    buyCannonTowerBtn.classList.add('active');
                    // Remove active class from other buttons
                    buyBasicTowerBtn.classList.remove('active');
                    buyKnightBtn.classList.remove('active');
                    buyBombBtn.classList.remove('active'); // Remove active state from bomb button
                    showMessage(`Place thy mighty cannon tower!`);
                } else {
                    showMessage("Thou hast not enough coin for a cannon tower!");
                }
            });

            // Event listener for the new Bomb button
            buyBombBtn.addEventListener('click', () => {
                if (money >= towerConfigs.bomb.cost) {
                    placingTower = true;
                    selectedTowerType = 'bomb';
                    buyBombBtn.classList.add('active');
                    // Remove active class from other buttons
                    buyBasicTowerBtn.classList.remove('active');
                    buyKnightBtn.classList.remove('active');
                    buyCannonTowerBtn.classList.remove('active');
                    showMessage(`Tap to deploy the mighty bomb!`);
                } else {
                    showMessage("Thou hast not enough coin for a bomb!");
                }
            });

            // Pause button functionality
            pauseButton.addEventListener('click', () => {
                paused = !paused;
                if (paused) {
                    cancelAnimationFrame(animationFrameId); // Stop the game loop
                    pauseButton.innerHTML = '<i class="fas fa-play"></i>'; // Change icon to play
                    showMessage("Game Paused. Click play to resume.");
                } else {
                    // No need to requestAnimationFrame here, as it's called at the end of gameLoop
                    // when paused is false. This prevents multiple requests.
                    pauseButton.innerHTML = '<i class="fas fa-pause"></i>'; // Change icon to pause
                    showMessage("Game Resumed.");
                }
            });

            // Canvas click listener for placing towers
            canvas.addEventListener('click', (event) => {
                if (!placingTower) return; // Only proceed if in placement mode

                const rect = canvas.getBoundingClientRect();
                // Calculate click coordinates relative to the canvas's internal resolution
                const x = (event.clientX - rect.left) * (canvas.width / rect.width);
                const y = (event.clientY - rect.top) * (canvas.height / rect.height);
                
                // Check if placement is on path for knights, or off path for basic/cannon towers
                const pathWidth = 60 * currentScaleFactor; // Scaled path width for collision detection
                let onPath = false;
                // Iterate through path segments to check if click is near any segment
                for (let i = 0; i < currentPath.length - 1; i++) {
                    const p1 = {x: currentPath[i].x * canvas.width, y: currentPath[i].y * canvas.height};
                    const p2 = {x: currentPath[i + 1].x * canvas.width, y: currentPath[i + 1].y * canvas.height};
                    
                    // Function to calculate distance from a point to a line segment
                    const distToSegment = (px, py, p1x, p1y, p2x, p2y) => {
                        const l2 = (p2x - p1x) ** 2 + (p2y - p1y) ** 2;
                        if (l2 === 0) return Math.sqrt((px - p1x) ** 2 + (py - p1y) ** 2);
                        const t = ((px - p1x) * (p2x - p1x) + (py - p1y) * (p2y - p1y)) / l2;
                        if (t < 0) return Math.sqrt((px - p1x) ** 2 + (py - p1y) ** 2);
                        if (t > 1) return Math.sqrt((px - p2x) ** 2 + (py - p2y) ** 2);
                        const projectionX = p1x + t * (p2x - p1x);
                        const projectionY = p1y + t * (p2y - p1y);
                        return Math.sqrt((px - projectionX) ** 2 + (py - projectionY) ** 2);
                    };
                    if (distToSegment(x, y, p1.x, p1.y, p2.x, p2.y) < pathWidth / 2) {
                        onPath = true;
                        break;
                    }
                }

                // Handle bomb placement specifically
                if (selectedTowerType === 'bomb') {
                    money -= towerConfigs.bomb.cost;
                    bombs.push(new Bomb(x, y, towerConfigs.bomb.damage, towerConfigs.bomb.range));
                    placingTower = false; // Exit placement mode
                    buyBombBtn.classList.remove('active');
                    showMessage(`A mighty explosion rocks the battlefield!`);
                    updateUI();
                    return; // Exit function after placing bomb
                }

                // Enforce placement rules: towers off path, knights on path
                if ((selectedTowerType === 'basic' || selectedTowerType === 'cannonTower') && onPath) {
                    showMessage("Thou mayest not place a tower upon the sacred path!");
                    return;
                }
                if (selectedTowerType === 'knight' && !onPath) {
                    showMessage("Thou mayest only place a knight upon the sacred path!");
                    return;
                }

                // Check for overlap with existing units (towers or knights)
                const newUnitConfig = towerConfigs[selectedTowerType];
                const newUnitScaledSize = newUnitConfig.size * currentScaleFactor;
                let overlapping = false;
                for (const unit of towers) {
                    const existingUnitScaledSize = towerConfigs[unit.type].size * currentScaleFactor;
                    const dist = Math.sqrt((x - unit.x) ** 2 + (y - unit.y) ** 2);
                    // Adjusted overlap threshold to allow units to be placed much closer
                    if (dist < (newUnitScaledSize * 0.15 + existingUnitScaledSize * 0.15)) { 
                        overlapping = true;
                        break;
                    }
                }

                if (overlapping) {
                    showMessage("Thou mayest not build upon an existing fortress!");
                    return;
                }

                // If all checks pass, place tower/knight and update state
                money -= newUnitConfig.cost;
                const newUnit = new Tower(x, y, selectedTowerType); // Use Tower class for both
                towers.push(newUnit);
                // Hide radius after a short delay
                setTimeout(() => {
                    newUnit.showRadius = false;
                }, 3000);

                placingTower = false; // Exit placement mode
                // Remove active class from all buttons
                buyBasicTowerBtn.classList.remove('active');
                buyKnightBtn.classList.remove('active');
                buyCannonTowerBtn.classList.remove('active');
                buyBombBtn.classList.remove('active'); // Remove active state from bomb button
                updateUI(); // Update money display
                showMessage(`Thy ${selectedTowerType} is built! Await the horde!`);
            });
            
            // Initialization function
            function init() {
                // Set canvas internal dimensions to the desired phone resolution
                canvas.width = BASE_WIDTH;
                canvas.height = BASE_HEIGHT;

                // Calculate initial scaling factor based on the defined base width and apply a zoom
                currentScaleFactor = (canvas.width / BASE_WIDTH) * 1.5; // 1.5x zoom relative to BASE_WIDTH

                // Function to handle canvas resizing to fit the window while maintaining aspect ratio
                function resizeCanvas() {
                    const gameContainer = document.getElementById('game-container');
                    const windowAspectRatio = window.innerWidth / window.innerHeight;
                    const gameAspectRatio = BASE_WIDTH / BASE_HEIGHT;

                    if (windowAspectRatio < gameAspectRatio) {
                        // Window is taller/narrower than game, constrained by width
                        gameContainer.style.width = '100vw';
                        gameContainer.style.height = `calc(100vw / ${gameAspectRatio})`;
                    } else {
                        // Window is wider/shorter than game, constrained by height
                        gameContainer.style.height = '100vh';
                        gameContainer.style.width = `calc(100vh * ${gameAspectRatio})`;
                    }
                }
                resizeCanvas(); // Call once on init
                window.addEventListener('resize', resizeCanvas); // Add listener for window resize

                // Initially hide game UI elements
                statsOverlay.style.display = 'none';
                document.getElementById('tower-buttons').style.display = 'none';
                pauseButtonContainer.style.display = 'none';

                // Show the how-to-play screen
                howToPlayScreen.style.display = 'flex';

                // Load all assets before starting the game
                loadAssets(() => {
                    loadingOverlay.style.display = 'none'; // Hide loading screen
                    // Game starts only after "Start Game" button is clicked
                });
            }

            // Event listener for the "Start Game" button on the intro screen
            startGameIntroBtn.addEventListener('click', () => {
                howToPlayScreen.style.display = 'none'; // Hide the intro screen
                statsOverlay.style.display = 'flex'; // Show stats
                document.getElementById('tower-buttons').style.display = 'flex'; // Show tower buttons
                pauseButtonContainer.style.display = 'block'; // Show pause button

                updateUI(); // Initial UI update
                drawBackground(); // Draw initial background
                drawPath(); // Draw initial path
                spawnInitialTower(); // Place the first tower for free
                
                // Start the game immediately
                gameActive = true;
                spawnWave();
                showMessage(`Behold! The enemy approaches!`);
                requestAnimationFrame(gameLoop);
            });

            init(); // Call init to start the game setup
        };
    </script>
</body>
</html>

